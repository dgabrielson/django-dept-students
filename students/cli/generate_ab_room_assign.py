#!/usr/bin/env python
#! -*- encoding: utf-8 -*-
"""
Generate alphabetical room assignments, based on room capacity.

INPUTS:
    Master classlist, as generated by master_list_generator.py
    Room assignment list, CSV of (room, capacity) pairs.
"""
#######################
from __future__ import print_function, unicode_literals

import csv
import os
import pprint
import random
import sys

from django.utils import six

#######################
SEATS_PER_STUDENT = 2


def csv_load(input_filename_or_fp, delimiter=None, skip_blanks=True):
    """
    This function is designed to be 'the' csv loading code.
    """
    if isinstance(input_filename_or_fp, six.string_types):
        fp = open(input_filename_or_fp)
    else:
        fp = input_filename_or_fp

    txt = fp.read().replace("\r", "\n")  # deal with either line-ending.
    # warning: skip_blanks set False may interfer!

    if delimiter is None:
        # autodetect delimiter: tabs, commas, semicolons
        possible_delimiters = [",", "\t", ";"]
        count_dict = {}
        for d in possible_delimiters:
            count_dict[d] = txt.count(d)
        delimiter = ""
        score = -1
        for d in possible_delimiters:
            if count_dict[d] > score:
                score = count_dict[d]
                delimiter = d

    results = []
    for row in csv.reader(txt.split("\n"), delimiter=delimiter):
        if row or not skip_blanks:
            results.append(row)

    return results


def check_capacity(classlist, roomlist, seats_per_student=SEATS_PER_STUDENT):
    students = len(classlist)
    capacity = sum([int(r[1]) for r in roomlist])
    rooms = len(roomlist)
    # divide excess capacity among rooms
    extra_cap = capacity - seats_per_student * students
    assert extra_cap > 0, (
        "There is no extra capicity (students: %d, rooms: %d, capacity: %d, seats/student: %d)"
        % (students, rooms, capacity, seats_per_student)
    )
    return students, capacity


# def do_assignments(classlist, roomlist, slack, seats_per_student= SEATS_PER_STUDENT):
#     start_idx = 0
#     results = {}    # a dictionary of room names to a slice in classlist
#     for room, capacity_str in roomlist:
#         capacity = int(capacity_str)
#         stop_idx = start_idx + capacity/seats_per_student - int(slack) + 1
#         results[room] = classlist[start_idx:stop_idx]
#         start_idx = stop_idx
#     return results


def do_assignments(
    classlist,
    roomlist,
    target_percent=1.0,
    max_letters=2,
    seats_per_student=SEATS_PER_STUDENT,
):
    start_idx = 0
    results = {}  # a dictionary of room names to a slice in classlist

    roomdict = dict([(r[0], int(r[1])) for r in roomlist])
    rooms = roomdict.keys()

    room_idx = 0
    room = rooms[room_idx]
    capacity = roomdict[room]
    target_capacity = target_percent * capacity
    target_seats = target_capacity // seats_per_student
    seat_count = 0
    results[room] = []
    student_idx = 0
    while True:  # every student gets a seat
        student_row = classlist[student_idx]
        results[room].append(student_row)
        seat_count += 1
        if seat_count >= target_seats:
            # determine if this is actually a good break point.
            # advance room
            room_idx += 1
            room = rooms[room_idx]
            capacity = roomdict[room]
            target_capacity = target_percent * capacity
            target_seats = target_capacity // seats_per_student
            seat_count = 0
            results[room] = []
        student_idx += 1
        if student_idx == len(classlist):
            break  # we are done
    return results

    # random.shuffle(roomlist)
    for room, capacity_str in roomlist:
        capacity = int(capacity_str)
        target_count = target_percent * capacity
        student_count = int(target_count / seats_per_student)
        stop_idx = start_idx + student_count + 1
        # advance stop_idx, until there are at most max_letters - 1 the same.
        try:
            offset = 0
            while True:
                if (
                    classlist[stop_idx - 1][0][:max_letters].lower()
                    != classlist[stop_idx][0][:max_letters].lower()
                ):
                    break
                # this code ping-pongs the stop_idx with the offsets: +1,-2,+3,-4,...
                if offset == 0:
                    offset = -1
                elif offset > 0:
                    offset += 1
                else:
                    offset -= 1
                offset *= -1
                if (stop_idx + offset - start_idx) * seats_per_student > capacity:
                    # only go backwards:
                    if offset > 0:
                        offset *= -1
                stop_idx += offset

        except IndexError:  # can happen at the end of the list.
            pass

        results[room] = classlist[start_idx:stop_idx]
        start_idx = stop_idx
    return results


def find_best_assignment(classlist, roomlist, seats_per_student=SEATS_PER_STUDENT):
    """

    """
    students, capacity = check_capacity(classlist, roomlist, seats_per_student)
    assignments = do_assignments(classlist, roomlist, 1.0, seats_per_student)
    return assignments


def make_blocks(classlist, max_letters):
    intermediate = {}
    for row in classlist:
        key = row[0][:max_letters].lower()
        if key in intermediate:
            intermediate[key].append(row)
        else:
            intermediate[key] = [row]
    keys = sorted(intermediate)
    results = []
    for k in keys:
        results.append([k, intermediate[k]])
    return results


def check_assignment(rooms, assignments, roomdict, target_percent, seats_per_student):
    flag = True
    print("=" * 40)
    for room in rooms:
        blocks = assignments[room]
        capacity = roomdict[room]
        total = sum([len(b[1]) for b in blocks])
        if total * seats_per_student >= capacity:
            flag = False
            # return False    # not done yet!
        print(
            "%d\t%d\t%d\t%s\t%r"
            % (
                capacity,
                total,
                capacity - total * seats_per_student,
                room,
                [b[0] for b in blocks],
            )
        )
    # return True
    sys.stdout.flush()
    input()
    return flag


def smooth_assignment(rooms, assignments, roomdict, target_percent, seats_per_student):
    for idx in range(len(rooms) - 1):
        room = rooms[idx]
        blocks = assignments[room]
        capacity = roomdict[room]
        total = sum([len(b[1]) for b in blocks])
        if total * seats_per_student >= capacity:
            next_room = rooms[idx + 1]
            # take the last block in this room, and move it into the first block of the next room.
            block = blocks.pop()
            assignments[next_room].insert(0, block)
        # Should I worry about if this room is empty?
    return assignments


def assign_blocks(class_blocks, roomdict, target_percent, seats_per_student):
    block_idx = 0
    results = {}
    rooms = sorted(roomdict.keys(), key=lambda r: roomdict[r])  # biggest at the end
    # random.shuffle(rooms)

    done = False
    block_count = len(class_blocks)
    room_count = len(rooms)
    chunk_size = block_count // room_count + 1

    # first pass, layout evenly.
    start_chunk = 0
    for room in rooms:
        capacity = roomdict[room]
        results[room] = class_blocks[start_chunk : start_chunk + chunk_size]
        start_chunk += chunk_size

    tries = 0
    while not check_assignment(
        rooms, results, roomdict, target_percent, seats_per_student
    ):
        count = 0
        for r in results:
            count += len(results[r])
        assert count == len(class_blocks), "not all the class blocks are in play"  #
        results = smooth_assignment(
            rooms, results, roomdict, target_percent, seats_per_student
        )
        tries += 1
        if tries > 1e6:
            return None

    return results


#     for room, capacity_str in roomlist:
#         capacity = int(capacity_str)
#         target_count = target_percent*capacity
#         max_count = capacity/seats_per_student
#         count = 0
#         results[room] = []
#         while True:
#             block_count = len(class_blocks[block_idx][1])
#             if count + block_count >= max_count:
#                 break
#             count += block_count
#             results[room].append( class_blocks[block_idx][0] )
# #             if count >= target_count:
# #                 break
#             results
#             block_idx += 1
#             if block_idx == len(class_blocks):
#                 done = True # everybody assigned.
#                 break
#
#     if  done:
#         return results
#
#     return []
#
#     assert block_idx == len(class_blocks), 'there are still people unassigned'
#     return []


def main(classlist_fn, roomlist_fn, seats_per_student=SEATS_PER_STUDENT, max_letters=2):
    classlist = csv_load(classlist_fn)  # list of (name, number, section)
    roomlist = csv_load(roomlist_fn)  # list of (room, capacity)
    roomdict = dict([(row[0], int(row[1])) for row in roomlist])
    assignments = find_best_assignment(classlist, roomlist, seats_per_student)
    by_name = {}
    for room in assignments:
        students = assignments[room]

        start = students[0][0]
        finish = students[-1][0]
        count = len(students)
        by_name[start] = [finish, count, room]
    keys = sorted(by_name.keys(), key=lambda s: s.lower())
    for start in keys:
        finish, count, room = by_name[start]
        print(
            str(roomdict[room])
            + "\t"
            + str(count)
            + "\t"
            + start[:2]
            + "\t"
            + finish[:2]
            + "\t"
            + room
        )


if __name__ == "__main__":
    classlist_filename = sys.argv[1]
    roomlist_filename = sys.argv[2]
    main(classlist_filename, roomlist_filename)
